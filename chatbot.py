# -*- coding: utf-8 -*-
"""ChatBot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10u4LD4skXfrQgsJBYkegCU3DVNoe9q4Z
"""

import random

def detectar_emocion(texto):
    texto = texto.lower()
    if any(palabra in texto for palabra in ["triste", "mal", "deprimido", "bajón", "desanimado"]):
        return "triste"
    elif any(palabra in texto for palabra in ["ansioso", "nervioso", "preocupado", "estresado"]):
        return "ansioso"
    elif any(palabra in texto for palabra in ["feliz", "bien", "contento", "alegre", "genial"]):
        return "feliz"
    elif any(palabra in texto for palabra in ["enojado", "molesto", "frustrado", "irritado"]):
        return "enojado"
    elif "ayuda" in texto:
        return "ayuda"
    else:
        return "desconocido"

def obtener_respuesta(emocion):
    respuestas = {
        "triste": [
            "Lo siento que te sientas así 😔. ¿Quieres contarme qué te preocupa?",
            "Es normal sentirse triste a veces 😢. Estoy aquí para escucharte.",
            "Lamento que estés pasando por un momento difícil 💙. ¿Quieres hablar más sobre ello?"
        ],
        "ansioso": [
            "La ansiedad puede ser muy difícil 😟. Respira profundo, estoy aquí contigo.",
            "Entiendo que te sientas ansioso 😰. ¿Quieres intentar relajarte juntos?",
            "A veces ayuda hablar de lo que nos preocupa 🧘. ¿Quieres intentarlo?"
        ],
        "feliz": [
            "¡Qué bueno que te sientas feliz 😄! ¿Qué te ha hecho sentir así?",
            "Me alegra mucho escuchar eso 🎉. ¡Disfruta ese momento!",
            "La felicidad es contagiosa 😃, gracias por compartirla conmigo."
        ],
        "enojado": [
            "Está bien sentirse enojado a veces 😠. ¿Quieres contarme qué pasó?",
            "La ira puede ser fuerte 🔥, pero hablar ayuda a calmarla.",
            "¿Quieres que te escuche? A veces expresar lo que sentimos ayuda 🤗."
        ],
        "ayuda": [
            "Estoy aquí para apoyarte 🤝. ¿Qué te gustaría compartir?",
            "Cuéntame más, estoy para escucharte 👂.",
            "No estás solo 🧑‍🤝‍🧑, dime cómo puedo ayudarte."
        ],
        "desconocido": [
            "Entiendo 🤔. Cuéntame más, por favor.",
            "Estoy aquí para escucharte, sigue hablando 🗣️.",
            "Gracias por compartir conmigo 🙏. ¿Quieres contarme más?"
        ]
    }
    return random.choice(respuestas[emocion])

def chatbot():
    print("Hola, soy tu chatbot de apoyo emocional 😊. ¿Cómo te sientes hoy?")

    while True:
        user_input = input("Tú: ").strip()
        if user_input.lower() in ["salir", "adios", "chao"]:
            print("Chatbot: Cuídate mucho 👋. ¡Hasta luego!")
            break

        emocion = detectar_emocion(user_input)
        respuesta = obtener_respuesta(emocion)
        print("Chatbot:", respuesta)

# Ejecutar chatbot en Colab
chatbot()

import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.tree import DecisionTreeClassifier, plot_tree

# Dataset
frases = [
    "Estoy triste", "Me siento deprimido", "Qué bajón", "Estoy desanimado",
    "Estoy nervioso", "Me siento ansioso", "Estoy estresado", "Tengo preocupación",
    "Estoy feliz", "Me siento bien", "Estoy contento", "Qué alegre estoy", "Me siento genial",
    "Estoy enojado", "Me siento molesto", "Estoy frustrado", "Estoy irritado",
    "Necesito ayuda", "Por favor ayúdame", "Quiero apoyo"
]

emociones = [
    "triste", "triste", "triste", "triste",
    "ansioso", "ansioso", "ansioso", "ansioso",
    "feliz", "feliz", "feliz", "feliz", "feliz",
    "enojado", "enojado", "enojado", "enojado",
    "ayuda", "ayuda", "ayuda"
]

# Vectorización
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(frases)

# Entrenar árbol sin limitar profundidad
clf = DecisionTreeClassifier(max_depth=None, random_state=42)
clf.fit(X, emociones)

# Mostrar clases aprendidas
print("📌 Emociones aprendidas por el árbol:", clf.classes_)

# Graficar árbol completo
plt.figure(figsize=(30, 15))
plot_tree(
    clf,
    filled=True,
    feature_names=vectorizer.get_feature_names_out(),
    class_names=clf.classes_,  # se muestran TODAS las emociones aprendidas
    fontsize=12,
    rounded=True
)
plt.show()

import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import numpy as np

# Ejemplo simplificado: 100 frases por emoción (aumenta según necesidad)
# Aquí solo pongo 50 por emoción, en práctica puedes ampliar a 100-200
frases = []
emociones = []

emociones_list = ["triste", "ansioso", "feliz", "enojado", "ayuda"]
for emo in emociones_list:
    for i in range(50):  # 50 frases por emoción
        frases.append(f"Frase {i+1} de emoción {emo}")  # reemplaza con frases reales variadas
        emociones.append(emo)

# Vectorización TF-IDF con n-grams
vectorizer = TfidfVectorizer(ngram_range=(1,2))
X = vectorizer.fit_transform(frases)

# Train/Test split
X_train, X_test, y_train, y_test = train_test_split(
    X, emociones, test_size=0.2, random_state=42, stratify=emociones
)

# Random Forest robusto
clf = RandomForestClassifier(n_estimators=1000, random_state=42)
clf.fit(X_train, y_train)

# Precisión
y_pred = clf.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f"🎯 Precisión del modelo: {accuracy*100:.2f}%")

# Frases de prueba
frases_prueba = [
    "Hoy estoy triste y desanimado",
    "Me siento muy ansioso y estresado",
    "Hoy estoy feliz y contento",
    "Estoy enojado y muy molesto",
    "Necesito ayuda urgente"
]

X_new = vectorizer.transform(frases_prueba)
probs = clf.predict_proba(X_new)
clases = clf.classes_

# Gráfico de barras
x = np.arange(len(clases))
width = 0.15
plt.figure(figsize=(12, 6))
for i, frase in enumerate(frases_prueba):
    plt.bar(x + i*width, probs[i], width, label=frase)

plt.xticks(x + width*2, clases)
plt.title("Probabilidades de predicción por emoción")
plt.ylabel("Probabilidad")
plt.ylim(0, 1)
plt.legend(bbox_to_anchor=(1.05, 1), loc="upper left")
plt.show()