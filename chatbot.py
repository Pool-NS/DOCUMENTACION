# -*- coding: utf-8 -*-
"""ChatBot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10u4LD4skXfrQgsJBYkegCU3DVNoe9q4Z
"""

import random

def detectar_emocion(texto):
    texto = texto.lower()
    if any(palabra in texto for palabra in ["triste", "mal", "deprimido", "bajÃ³n", "desanimado"]):
        return "triste"
    elif any(palabra in texto for palabra in ["ansioso", "nervioso", "preocupado", "estresado"]):
        return "ansioso"
    elif any(palabra in texto for palabra in ["feliz", "bien", "contento", "alegre", "genial"]):
        return "feliz"
    elif any(palabra in texto for palabra in ["enojado", "molesto", "frustrado", "irritado"]):
        return "enojado"
    elif "ayuda" in texto:
        return "ayuda"
    else:
        return "desconocido"

def obtener_respuesta(emocion):
    respuestas = {
        "triste": [
            "Lo siento que te sientas asÃ­ ğŸ˜”. Â¿Quieres contarme quÃ© te preocupa?",
            "Es normal sentirse triste a veces ğŸ˜¢. Estoy aquÃ­ para escucharte.",
            "Lamento que estÃ©s pasando por un momento difÃ­cil ğŸ’™. Â¿Quieres hablar mÃ¡s sobre ello?"
        ],
        "ansioso": [
            "La ansiedad puede ser muy difÃ­cil ğŸ˜Ÿ. Respira profundo, estoy aquÃ­ contigo.",
            "Entiendo que te sientas ansioso ğŸ˜°. Â¿Quieres intentar relajarte juntos?",
            "A veces ayuda hablar de lo que nos preocupa ğŸ§˜. Â¿Quieres intentarlo?"
        ],
        "feliz": [
            "Â¡QuÃ© bueno que te sientas feliz ğŸ˜„! Â¿QuÃ© te ha hecho sentir asÃ­?",
            "Me alegra mucho escuchar eso ğŸ‰. Â¡Disfruta ese momento!",
            "La felicidad es contagiosa ğŸ˜ƒ, gracias por compartirla conmigo."
        ],
        "enojado": [
            "EstÃ¡ bien sentirse enojado a veces ğŸ˜ . Â¿Quieres contarme quÃ© pasÃ³?",
            "La ira puede ser fuerte ğŸ”¥, pero hablar ayuda a calmarla.",
            "Â¿Quieres que te escuche? A veces expresar lo que sentimos ayuda ğŸ¤—."
        ],
        "ayuda": [
            "Estoy aquÃ­ para apoyarte ğŸ¤. Â¿QuÃ© te gustarÃ­a compartir?",
            "CuÃ©ntame mÃ¡s, estoy para escucharte ğŸ‘‚.",
            "No estÃ¡s solo ğŸ§‘â€ğŸ¤â€ğŸ§‘, dime cÃ³mo puedo ayudarte."
        ],
        "desconocido": [
            "Entiendo ğŸ¤”. CuÃ©ntame mÃ¡s, por favor.",
            "Estoy aquÃ­ para escucharte, sigue hablando ğŸ—£ï¸.",
            "Gracias por compartir conmigo ğŸ™. Â¿Quieres contarme mÃ¡s?"
        ]
    }
    return random.choice(respuestas[emocion])

def chatbot():
    print("Hola, soy tu chatbot de apoyo emocional ğŸ˜Š. Â¿CÃ³mo te sientes hoy?")

    while True:
        user_input = input("TÃº: ").strip()
        if user_input.lower() in ["salir", "adios", "chao"]:
            print("Chatbot: CuÃ­date mucho ğŸ‘‹. Â¡Hasta luego!")
            break

        emocion = detectar_emocion(user_input)
        respuesta = obtener_respuesta(emocion)
        print("Chatbot:", respuesta)

# Ejecutar chatbot en Colab
chatbot()

import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.tree import DecisionTreeClassifier, plot_tree

# Dataset
frases = [
    "Estoy triste", "Me siento deprimido", "QuÃ© bajÃ³n", "Estoy desanimado",
    "Estoy nervioso", "Me siento ansioso", "Estoy estresado", "Tengo preocupaciÃ³n",
    "Estoy feliz", "Me siento bien", "Estoy contento", "QuÃ© alegre estoy", "Me siento genial",
    "Estoy enojado", "Me siento molesto", "Estoy frustrado", "Estoy irritado",
    "Necesito ayuda", "Por favor ayÃºdame", "Quiero apoyo"
]

emociones = [
    "triste", "triste", "triste", "triste",
    "ansioso", "ansioso", "ansioso", "ansioso",
    "feliz", "feliz", "feliz", "feliz", "feliz",
    "enojado", "enojado", "enojado", "enojado",
    "ayuda", "ayuda", "ayuda"
]

# VectorizaciÃ³n
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(frases)

# Entrenar Ã¡rbol sin limitar profundidad
clf = DecisionTreeClassifier(max_depth=None, random_state=42)
clf.fit(X, emociones)

# Mostrar clases aprendidas
print("ğŸ“Œ Emociones aprendidas por el Ã¡rbol:", clf.classes_)

# Graficar Ã¡rbol completo
plt.figure(figsize=(30, 15))
plot_tree(
    clf,
    filled=True,
    feature_names=vectorizer.get_feature_names_out(),
    class_names=clf.classes_,  # se muestran TODAS las emociones aprendidas
    fontsize=12,
    rounded=True
)
plt.show()

import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import numpy as np

# Ejemplo simplificado: 100 frases por emociÃ³n (aumenta segÃºn necesidad)
# AquÃ­ solo pongo 50 por emociÃ³n, en prÃ¡ctica puedes ampliar a 100-200
frases = []
emociones = []

emociones_list = ["triste", "ansioso", "feliz", "enojado", "ayuda"]
for emo in emociones_list:
    for i in range(50):  # 50 frases por emociÃ³n
        frases.append(f"Frase {i+1} de emociÃ³n {emo}")  # reemplaza con frases reales variadas
        emociones.append(emo)

# VectorizaciÃ³n TF-IDF con n-grams
vectorizer = TfidfVectorizer(ngram_range=(1,2))
X = vectorizer.fit_transform(frases)

# Train/Test split
X_train, X_test, y_train, y_test = train_test_split(
    X, emociones, test_size=0.2, random_state=42, stratify=emociones
)

# Random Forest robusto
clf = RandomForestClassifier(n_estimators=1000, random_state=42)
clf.fit(X_train, y_train)

# PrecisiÃ³n
y_pred = clf.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f"ğŸ¯ PrecisiÃ³n del modelo: {accuracy*100:.2f}%")

# Frases de prueba
frases_prueba = [
    "Hoy estoy triste y desanimado",
    "Me siento muy ansioso y estresado",
    "Hoy estoy feliz y contento",
    "Estoy enojado y muy molesto",
    "Necesito ayuda urgente"
]

X_new = vectorizer.transform(frases_prueba)
probs = clf.predict_proba(X_new)
clases = clf.classes_

# GrÃ¡fico de barras
x = np.arange(len(clases))
width = 0.15
plt.figure(figsize=(12, 6))
for i, frase in enumerate(frases_prueba):
    plt.bar(x + i*width, probs[i], width, label=frase)

plt.xticks(x + width*2, clases)
plt.title("Probabilidades de predicciÃ³n por emociÃ³n")
plt.ylabel("Probabilidad")
plt.ylim(0, 1)
plt.legend(bbox_to_anchor=(1.05, 1), loc="upper left")
plt.show()